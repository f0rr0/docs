---
title: Testing
metaDescription:
---

<TopBlock>

Testing is a key aspect of developing any application with production-grade ambitions.

This article explores what testing an application talking to a database involves, the various testing approaches and how Prisma fits in this picture.

We assume that you are already convinced about the motivations behind writing automated tests for an application. If not, we advise you to read [this article](https://dev-tester.com/why-should-i-waste-time-writing-automated-tests/) going through the topic in detail.

We'll focus on the following types of tests:

1. **Unit tests** - Testing an individual and well isolated code path or function.
2. **Integration tests** - Testing how a set of components from the application function together as a whole.
3. **End-to-end tests** - Testing a usage scenario on the application as a user would.

We will unpack what is involved in these types of tests, where and how Prisma can help.

</TopBlock>

## Unit testing

Unit tests aim at testing a small portion of code intended to get a set of predictable behaviors. In the context of testing a function performing a database call using the Prisma client, testing the Prisma call itself would not add value as we do that for you already ðŸ™‚. Instead, the test should focus on what the function does with the data returned by the Prisma client and ensure that it behaves as expected.

This means that you should aim at removing dependencies such as the availability of external services, a database, etc... from your unit tests to make them as lightweight and portable as possible.

A typical way to go about this is to use mocks. For Prisma, this means to fake the client's responses so that the test checks the function behavior depending on these responses.

To illustrate this, imagine a function returning a different result depending on how many products are left in an inventory. The unit test would test two scenarios: one with a product having items in stock, and one with a product being out of stock. It wouldn't test that Prisma can effectively return a product based on its ID.

[You can check out a concrete example of how to mock the Prisma client using a middleware here](https://www.notion.so/Mocking-example-article-c59d847122e941f68e2aca2f78f69ab2).

If you want your unit test to also check that the Prisma client call is made appropriately, and returns the expected information, you're looking at an integration test. Let's go through these now.

## Integration tests and database setup

Integration tests focus on testing how separate parts of the program work together. In the context of applications using a database, integration tests usually require a database to be available and contain data that is convenient to the scenarios intended to be tested.

Taking an e-commerce application example, an integration test could be checking that the order fulfillment flow is working properly. This means:

- Getting a fake order for a fake customer
- Submitting the order, checking for inventory
- Issuing an invoice
- Sending a confirmation email

That flow relies on the following data to be available in the database:

- 1 customer
- a few products with inventory and price information

The email service could be mocked for the sake of simplification, or warrant a separate test checking for a valid processing of the outcome of sending the email.

**Approaches**

- **Using containers like Docker - preferred**: in this approach, you spin up a database in a container which comes with a test data set, that will support your various testing scenarios.
- **Using a local development database:** this is similar to the container-based approach but uses your local development environment. This comes with tradeoffs as people working on the same team would need to ensure they can also run these local tests.

### Using Prisma to set the testing database up

This part assumes that you're not familiar with Prisma migrate. If that's not the case, get yourself a coffee and go through [the Prisma migrate introduction](https://www.prisma.io/docs/concepts/components/prisma-migrate) before coming back here ðŸ™‚

Prisma migrate offers a [reset](https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-reset) command. It entirely resets a database, runs all migrations available to bring its schema to the latest state, and executes any [seeding script](https://www.prisma.io/docs/guides/prisma-guides/seed-database/) next to each migration.

**Bear in mind to run this in a local or testing environment only!**

This is particularly useful for integration tests, which can structured as follows:

1. A container with (at least) 2 services: 
    1. The test database server
    2. The application server along with environment variables pointing to the database server
    3. (Any other service your application may also depend on)
2. A script running
    1. `prisma migrate reset --force` to reset the database and run seed scripts contained in the migrations folder
    2. Your test

### Migrate reset recommendations

**Don't run `prisma migrate reset` in production!**

Tests making changes to data (e.g updating or deleting test data initialized in your seed script) require to reset the database before another test gets executed. The easiest way to go about it is to reset the test database before any integration test is run. This will however make the test suite take longer as it grows. 

To optimize the duration, you can segment tests by type to run `prisma migrate reset` only when needed. In practice, this mean to bundle read-only tests in one suite, requiring a single reset.
Tests updating or deleting data can run `prisma migrate reset` in the `tearDown` process to leave the test database clean for their successors. 

### Integration tests and database connection

If you're running parallel tests, you need to ensure that each test is connecting (in `setUp`) and disconnecting (in `tearDown`) appropriately to avoid running into connection limits.

If your deployment setup involves a specific connection mechanism, such as a database proxy like `pgbouncer` or similar, it can be worth having a dedicated testing environment to run your integration test suite in, so that this setup is also tested.

As you may have noted, this assumes that all the migrations are valid. But how does one ensures that a migration is indeed valid?

### Specific case: testing a migration

Since Prisma migrate allows to customize the SQL it generates, it can be useful to test that a given migration results in the expected state. This is particularly useful for migrations performing changes to the underlying data.

To do that, you can create an integration test that fetches data from a model after `prisma migrate reset` was called (hence the migration was applied) and tests for its values.

As an example, imagine a migration joining firstName and lastName into fullName: the test can check that users in the test data set do show the expected fullName after `prisma migrate reset` has been performed.

## End-to-end tests

End-to-end tests typically mimic the application's user behavior. It is testing the outcome of the execution of the program, rather than how the internals of the program individually behave (which is the point of unit and integration tests).

While they are involving different sets of technologies depending on your application (fetching URLs in case the application is an API, frameworks such as Cypress for testing user interfaces), they typically require a similar setup as the one explained in the [Integration tests](https://www.notion.so/Testing-overview-article-f26a234c84f940bf85b03bad0fed6d8f) section.

## Next steps

If you want to learn more about concrete examples for testing with Prisma, you can check out these great contributions from our community:

- [https://dev.to/eddeee888/how-to-write-tests-for-prisma-with-docker-and-jest-593i](https://dev.to/eddeee888/how-to-write-tests-for-prisma-with-docker-and-jest-593i)